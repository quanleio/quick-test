<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Window Scroll Interaction</title>
  
  <!-- Letsee SDK -->
  <script src="https://developer.letsee.io/api/webar?key=95b3e0c2fd6f8a7539e87b8e9ea7ec33b45ce405e93d9b48a090ddee58d6ec55"></script>
  
  <!-- THREE.js -->
  <script src="https://unpkg.com/three@0.124.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.124.0/examples/js/loaders/RGBELoader.js"></script>
  <script src="https://unpkg.com/three@0.124.0/examples/js/libs/stats.min.js"></script>
  
  <script type="text/javascript" src="//code.jquery.com/jquery-1.11.0.min.js"></script>
  <script type="text/javascript" src="//code.jquery.com/jquery-migrate-1.2.1.min.js"></script>
  
</head>
<body>
<script>
  let scene, camera, renderer, update, mixer, toystory, mesh;
  const clock = new THREE.Clock();
  const stats = new Stats();
  stats.showPanel(1);
  document.body.appendChild(stats.dom);

  /**
   * Initialize Scene.
   */
  function initScene() {
  
    // Add lights
    let dirLight = new THREE.DirectionalLight(0xffffff, 2.5);
    dirLight.position.set(-0.5, 0.5, 0.866);
    dirLight.castShadow = false;
    dirLight.shadow.mapSize = new THREE.Vector2(512, 512);
    scene.add(dirLight);
  
    let pmremGenerator = new THREE.PMREMGenerator(renderer);
    pmremGenerator.compileEquirectangularShader();
  
    // 2. Set background for scene as image
    new THREE.RGBELoader().setDataType(THREE.UnsignedByteType).
      setPath('textures/').
      load('royal_esplanade_1k.hdr', function(texture) {
      
        let envMap = pmremGenerator.fromEquirectangular(texture).texture;
      
        scene.environment = envMap;
      
        texture.dispose();
        pmremGenerator.dispose();
      
      });
  
    renderer.toneMappingExposure = 1;
    renderer.toneMapping = 0;
    renderer.gammaFactor = 2;
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.physicallyCorrectLights = true;
    renderer.setPixelRatio( window.devicePixelRatio );
  }

  /**
   * Add model into Entity
   */
  function proceedModel() {
    letsee.addTarget('toystory.json').then(entity => {
      toystory = entity;
  
      mesh = new THREE.Mesh(
        new THREE.BoxBufferGeometry(100, 100, 100),
        new THREE.MeshNormalMaterial());
  
      // 2.Add mesh into entity
      toystory.add(mesh);
  
      // 3. Add entity to scene
      scene.add(toystory);
    
      // Render all
      renderAll().then(() => {
      });
    });
  }

  /**
   * Render all.
   * @returns {Promise<void>}
   */
  const renderAll = async function() {
    requestAnimationFrame(renderAll);
  
    camera = letsee.threeRenderer().getDeviceCamera();
    
    if (mesh) mesh.rotation.y += 0.001;
  
    renderer.render(scene, camera);
    await letsee.threeRenderer().update();
    stats.update();
  };

  window.onmousewheel = (e) => {
    if (mesh) {
      mesh.rotation.x += e.deltaY / 100.0;
    }
  };

  var triggers = 0;
  $(document).on('mousewheel', function(e) {
    // $('.count').text(++triggers);
  });

  $(document).on('touchmove', function(e) { //touchmove works for iOS, I don't know if Android supports it
    $(document).trigger('mousewheel');
    // $('.count').text(++triggers);
  
    console.warn(e);
    // if (mesh) {
    //   mesh.rotation.x += e.deltaY / 100.0;
    // }
  });
  
  letsee.ready(() => {
    letsee.start();
    
    letsee.addTHREE(THREE).then(obj => {
      camera = obj.camera;
      renderer = obj.renderer;
      scene = obj.scene;
      
      initScene();
      proceedModel();
    });
    
    letsee.onTrackStart(() => {});
    letsee.onTrackEnd(() => {});
    letsee.onTrackMove(() => {
      if (toystory.children.length > 0) toystory.children[0].visible = true;
    });
  });
  letsee.init();
</script>
</body>
</html>